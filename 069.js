/* 문제69 : 골드바흐의 추측

골드바흐의 추측(Goldbach's conjecture)은 오래전부터 알려진 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 개의 소수(Prime number)의 합으로 표시할 수 있다는 것이다. 이때 하나의 소수를 두 번 사용하는 것은 허용한다. - 위키백과

위 설명에서 2보다 큰 모든 짝수를 두 소수의 합으로 나타낸 것을 골드바흐 파티션이라고 합니다.

예)
100 == 47 + 53
56 == 19 + 37

2보다 큰 짝수 n이 주어졌을 때, 골드바흐 파티션을 출력하는 코드를 작성하세요. 

- 해당 문제의 출력 형식은 자유롭습니다. 가능하시다면 골드바흐 파티션 모두를 출력하거나, 그 차가 작은 것을 출력하거나 그 차가 큰 것 모두 출력해보세요.
*/

// 정답
// 소수 구하기
let prime = []; // 소수가 담길 배열
let isPrime = true; // 소수 판별 변수
let val = 100;
let 골드바흐파티션 = [];

for(let i = 2; i < val; i++){ // 1은 소수가 아니라서 2부터 시작
   for(let j = 2; j < i; j++){
     if(i % j == 0){ // 나누었을때 나머지가 0이라면
       isPrime = false; // 소수가 아니다
     }
   }
   if(isPrime){ 
     prime.push(i); // 소수만 prime 배열에 넣는다
   }
   isPrime = true; // 값을 넣고 나면 원래대로 true로 바꾼다.
}

for(let n of prime){ // 소수 배열을 하나씩 접근
  // 소수-원소의 값이 소수에 있는가, 같은수가 중복되는 수를 제외한다. 앞의 수가 뒤의 수보다 커질때
  if(prime.includes(val - n) && n <= (val - n)){ 
    골드바흐파티션.push([n, val - n])
  }
}

// 최종적으로 구한 수에서 큰수 - 작은수를 한 값을 차 배열에 넣는다.
let 차 = 골드바흐파티션.map(e => e[1] - e[0]);

// 차 배열안에서 가장 작은 값의 index가 골드바파티션의 인덱스가된다.
let 작은값 = 골드바흐파티션[차.indexOf(Math.min.apply(null,차))];
let 큰값 = 골드바흐파티션[차.indexOf(Math.max.apply(null,차))];

console.log(골드바흐파티션);
console.log(작은값);
console.log(큰값);
